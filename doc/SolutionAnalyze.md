# Анализ решения

Для беседы на интервью проанализировал свой код, сделал кое-какие выводы и подготовил список основных поинтов, чтобы
рассказывать о том, каким образом решал задачу, какие архитектурные приемы использовал, какие ошибки допустил.

### Задание

Напишите простой статический генератор сайтов.

Программа принимает на вход два пути к директориям. Первую директорию будем называть входной директорией, а вторую
— выходной.

Генератор должен обойти все файлы и поддиректории входной директории и выполнить для них следующее:

- Для каждой поддиректории входной директории должна создаваться соответствующая ей поддиректория в выходной директории.
- Каждый файл с расширением .gmi из входной директории должен транслироваться в соответствующий .html файл в выходной
  директории. Трансляция должна осуществляться в соответствии с форматом разметки gemtext.
- Каждый файл с расширением отличным от .gmi из входной директории должен копироваться в соответствующее ему место
  выходной директории или ее поддиректорий.

## Ход решения

#### Поисковик файлов и директорий

Необходимость поисковика. Интерфейсный класс BasicFSFinder. Решение использовать std::filesystem.
Поисковик регулярных файлов (надо сказать, что непосредственно занимается формированием списка файла).

### Транслятор

Суть транслятора (трансляция из одного формата в другой). Зона ответственности транслятора.
Общий алгоритм трансляции файла (построчная трансляция). Упомянуть способность отслеживать ошибки синтаксиса
и выбрасывать соответствующие исключения (спорное решение?).

### Генератор

Фактически фабричный метод, который связан с транслятором. Тут продуктом создателя (генератора) будет объект
транслятора. Итерация по директориям и поддиректориям, вывод результата в выходную директорию.

## Ошибки

- Несколько заигрался с созданиями классов исключений, сейчас мне кажется это не совсем правильный подход.
  Для примера, можно было бы не создавать классы `DirectoryNotFound` и `NotDirectory`, так как соответствующие
  исключения `std::filesystem` способна бросать самостоятельно.

- Зря сделал `BasicFilesFinder` шаблонным. Без шаблона интерфейс был бы более общим (если мы например хотим
  наследоваться и работать не на основе `std::filesystem`). Шаблонными следовало сделать классы наследники
  (при необходимости).
